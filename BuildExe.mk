# ============================================================================
# BuildExe.mk - Shared build configuration and rules
#
# Provides common variables, library builds, and link rules shared by
# BuildRelease.mk and BuildDebug.mk.  Each of those files sets BLD_DIR,
# CFLAGS, BUILD_TYPE, MAIN_EXE, and optionally PDB_TARGET before
# including this file.
#
# Library dependency order:
#   FormFact  (scattering factor tables, parsed from CSV/JSON via OCaml)
#   AtomXYZ   (molecular coordinates, parsed from .xyz files via OCaml)
#   Freq      (atom-type frequency tables)
#   Estimate  (SAXS intensity estimation)
#   CsvInterface (Fortran ↔ OCaml CSV bridge, requires OCaml runtime)
#
# OCaml toolchain is required for code-generation parsers and the CSV
# bridge.  Missing packages are detected and the user is prompted to
# install them via opam.
# ============================================================================

# ============================================================================
# COMPILER CONFIGURATIONS
# ============================================================================
CC           = gcc -w -g 			 # c compiler
FC           = gfortran  			 # fortran compiler
OCAMLFIND    = ocamlfind 
OC           = $(OCAMLFIND) ocamlopt # ocaml compiler
OPAM         = opam

# ============================================================================
# BUILD DIRECTORY CONFIGURATION
# ============================================================================
OBJ_DIR      = $(BLD_DIR)/obj
LIB_DIR      = $(BLD_DIR)/lib
MOD_DIR      = $(BLD_DIR)/mod
INC_DIR      = $(BLD_DIR)/inc
EXE_DIR      = $(BLD_DIR)/exe

# ============================================================================
# FORM_FACT LIBRARY CONFIGURATION
# Scattering factor lookup tables.  Source files (F0Factor.f90,
# F1F2Factors.f90) are generated by OCaml parsers from raw data;
# if missing they are regenerated automatically.
# ============================================================================
FF_DIR       = FormFact
FF_SRC_DIR   = $(FF_DIR)
FF_DATA_DIR  = $(FF_DIR)/data
FF_PARSE_DIR = $(FF_DIR)/parsers

FF_F0_SRC    = $(FF_SRC_DIR)/F0Factor.f90
FF_F12_SRC   = $(FF_SRC_DIR)/F1F2Factors.f90
FF_FF_SRC    = $(FF_SRC_DIR)/FormFact.f90

FF_F0_OBJ    = $(OBJ_DIR)/F0Factor
FF_F12_OBJ   = $(OBJ_DIR)/F1F2Factors.o
FF_FF_OBJ    = $(OBJ_DIR)/FormFact.o

FF_LIB       = $(LIB_DIR)/FormFact.a
FF_F0_DATA   = $(FF_DATA_DIR)/f0_factors/f0.csv
FF_F12_DATA  = $(FF_DATA_DIR)/f1_f2_factors/(12412.8)eV_f1_f2.json

# ============================================================================
# ATOM_XYZ LIBRARY CONFIGURATION
# Molecular geometry data.  Each .xyz file in AXY_DATA_DIR is parsed
# into a Fortran module by the OCaml XYZParser; the generated module
# list and include files let SaxsEst.f90 load molecules at compile time.
# ============================================================================
AXY_DIR      = AtomXYZ
AXY_SRC_DIR  = $(AXY_DIR)
AXY_DATA_DIR = $(AXY_DIR)/data
AXY_TMP_DIR  = $(AXY_SRC_DIR)/xyz_tmp
AXY_PARSE_DIR= $(AXY_DIR)/parsers

AXY_ATM_SRC  = $(AXY_SRC_DIR)/AtomXYZ.f90
AXY_ATM_OBJ  = $(OBJ_DIR)/Atom.o
AXY_XYZ_OBJ  = $(patsubst $(AXY_DATA_DIR)/%.xyz,$(OBJ_DIR)/xyz_%.o,$(wildcard $(AXY_DATA_DIR)/*.xyz))

AXY_LIB      = $(LIB_DIR)/AtomXYZ.a
AXY_LST      = $(BLD_DIR)/xyz_modules.txt
AXY_USE      = $(INC_DIR)/mod_uses.inc
AXY_SWT      = $(INC_DIR)/mod_switches.inc

# ============================================================================
# FREQ LIBRARY CONFIGURATION
# O(n) frequency table of unique atom types (see Freq.f90 for hash details).
# ============================================================================
FREQ_DIR     = Freq
FREQ_SRC_DIR = $(FREQ_DIR)

FREQ_SRC     = $(FREQ_SRC_DIR)/Freq.f90
FREQ_OBJ     = $(OBJ_DIR)/Freq.o
FREQ_LIB     = $(LIB_DIR)/Freq.a

# ============================================================================
# ESTIMATE LIBRARY CONFIGURATION
# Proportional-sampling Debye equation estimator for SAXS intensities.
# ============================================================================
EST_DIR      = Est
EST_SRC_DIR  = $(EST_DIR)

EST_SRC      = $(EST_SRC_DIR)/Est.f90
EST_OBJ      = $(OBJ_DIR)/Est.o
EST_LIB      = $(LIB_DIR)/Est.a

# ============================================================================
# CSV_INTERFACE LIBRARY CONFIGURATION
# Fortran ↔ OCaml bridge for CSV output.  Three layers:
#   CsvOut.ml     – OCaml CSV writer (compiled to a native object)
#   CsvBridge.c   – C shim between Fortran iso_c_binding and OCaml runtime
#   CsvInterface.f90 – Fortran-facing API
# ============================================================================
CSV_DIR      = CsvInterface
CSV_SRC_DIR  = $(CSV_DIR)

CSV_BRD_SRC  = $(CSV_SRC_DIR)/CsvBridge.c
CSV_BRD_OBJ  = $(OBJ_DIR)/CsvBridge.o
CSV_OUT_SRC  = $(CSV_SRC_DIR)/CsvOut.ml
CSV_OUT_OBJ  = $(OBJ_DIR)/CsvOut.o
CSV_API_SRC  = $(CSV_SRC_DIR)/CsvInterface.f90
CSV_API_OBJ  = $(OBJ_DIR)/CsvInterface.o
CSV_LIB      = $(LIB_DIR)/CsvInterface.a

# ============================================================================
# PDB_TO_XYZ EXECUTABLE CONFIGURATION
# Standalone converter: reads a PDB file and writes .xyz for use by AtomXYZ.
# ============================================================================
PDB_DIR      = pdb_to_xyz
PDB_SRC_DIR  = $(PDB_DIR)

PDB_SRC      = $(PDB_SRC_DIR)/pdb_to_xyz.f90
PDB_OBJ      = $(OBJ_DIR)/pdb_to_xyz.o
PDB_EXE      = $(EXE_DIR)/pdb_to_xyz

# ============================================================================
# MAIN EXECUTABLE CONFIGURATION
# ============================================================================
MAIN_DIR 	 = SaxsEst
MAIN_SRC     = $(MAIN_DIR)/SaxsEst.f90
MAIN_MOD     = $(MOD_DIR)/MaSaxsEstin.mod

# ============================================================================
# PHONY TARGETS
# ============================================================================
.PHONY: all all1 all2 FormFact AtomXYZ clean clean-build \
        parse-f0 parse-f1_f2 parse-xyz check-ocaml check-deps-csv \
        check-deps-yojson check-deps-str help clean-formfacts \
        clean-objects parse-xyz tabulate-xyz Estimate \
        postamble Freq compile-pdb-2-xyz make-outdir \
        generate-xyz-includes CsvInterface help

# ============================================================================
# ALL TARGET
# Libraries (all1) are built before the executable and CSV layer (all2).
# ============================================================================
all: all1 all2
all1: build-dirs FormFact AtomXYZ Freq Estimate 
all2: $(PDB_TARGET) CsvInterface main clean-objects postamble

# ============================================================================
# HELP TARGET
# ============================================================================
help:
	@echo "Usage: make -f $(MAKEFILE_NAME) <target>"
	@echo ""
	@echo "Build type: $(BUILD_TYPE)"
	@echo "CFLAGS: $(CFLAGS)"
	@echo ""
	@echo "Available targets:"
	@echo "  all              - Build all libraries and executables"
	@echo "  main             - Build main SAXS estimation executable"
	@echo "  FormFact         - Build FormFact library only"
	@echo "  AtomXYZ          - Build AtomXYZ library only"
	@echo "  Freq             - Build Freq library only"
	@echo "  Estimate         - Build Estimate library only"
	@echo "  CsvInterface    - Build CsvInterface library only"
ifdef PDB_TARGET
	@echo "  compile-pdb-2-xyz- Build pdb_to_xyz converter"
	@echo "  pdb-2-xyz        - Run pdb_to_xyz converter (prompts for filename)"
endif
	@echo ""
	@echo "Parsing targets:"
	@echo "  parse-f0         - Parse f0 scattering factors from CSV"
	@echo "  parse-f1_f2      - Parse f1_f2 anomalous factors from JSON"
	@echo "  parse-xyz        - Parse XYZ coordinate files"
	@echo ""
	@echo "Clean targets:"
	@echo "  clean            - Remove all build artifacts (note: clean-formfact not run!)"
	@echo "  clean-formfacts  - Remove generated f0 and f1_f2 modules"
	@echo "  clean-build      - Remove build directory"
	@echo "  clean-objects    - Remove all generated object files"
	@echo "  clean-all        - Run clean and clean-formfacts"

# ============================================================================
# BUILD DIRECTORIES
# ============================================================================
build-dirs:
	@mkdir -p $(OBJ_DIR) $(LIB_DIR) $(MOD_DIR) $(INC_DIR) $(EXE_DIR)

# ============================================================================
# FORM_FACT LIBRARY BUILD
# ============================================================================
FormFact: $(FF_LIB)

parse-f0: check-deps-csv
	@$(OC) -package csv -linkpkg $(FF_PARSE_DIR)/F0Parser.ml -o f0_gen && \
		./f0_gen "$(FF_F0_DATA)" && \
		mv F0Factor.f90 $(FF_SRC_DIR)/ && \
		rm -rf f0_gen

parse-f1_f2: check-deps-yojson
	@$(OC) -package yojson,str -linkpkg $(FF_PARSE_DIR)/F1F2Parser.ml -o f1_f2_gen && \
		./f1_f2_gen "$(FF_F12_DATA)" && \
		mv F1F2Factors.f90 $(FF_SRC_DIR)/ && \
		rm -rf f1_f2_gen

$(FF_LIB): $(FF_F0_OBJ) $(FF_F12_OBJ) $(FF_FF_OBJ)
	@ar rcs $@ $^

$(FF_F0_OBJ): $(FF_F0_SRC)
	@$(FC) $(CFLAGS) -J$(MOD_DIR) -c $< -o $@

$(FF_F12_OBJ): $(FF_F12_SRC)
	@$(FC) $(CFLAGS) -J$(MOD_DIR) -c $< -o $@

$(FF_FF_OBJ): $(FF_FF_SRC) $(FF_F0_OBJ) $(FF_F12_OBJ)
	@$(FC) $(CFLAGS) -I$(MOD_DIR) -J$(MOD_DIR) -c $< -o $@

# auto-generate F0Factor.f90 from CSV if it doesn't exist
$(FF_F0_SRC): | check-deps-csv
	@echo "F0Factor.f90 not found, parsing from $(FF_F0_DATA)"
	@$(OC) -package csv -linkpkg $(FF_PARSE_DIR)/F0Parser.ml -o f0_gen && \
		./f0_gen "$(FF_F0_DATA)" && \
		mv F0Factor.f90 $(FF_SRC_DIR)/ && \
		rm -rf f0_gen

# auto-generate F1F2Factors.f90 from JSON if it doesn't exist
$(FF_F12_SRC): | check-deps-yojson
	@echo "F1F2Factors.f90 not found, parsing from $(FF_F12_DATA)"
	@$(OC) -package yojson,str -linkpkg $(FF_PARSE_DIR)/F1F2Parser.ml -o f1_f2_gen && \
		./f1_f2_gen "$(FF_F12_DATA)" && \
		mv F1F2Factors.f90 $(FF_SRC_DIR)/ && \
		rm -rf f1_f2_gen

# ============================================================================
# ATOM_XYZ LIBRARY BUILD
# Pipeline: parse .xyz → generate per-molecule Fortran modules →
#           build module list → generate USE/SELECT CASE includes →
#           compile everything into a static library.
# ============================================================================
AtomXYZ: parse-xyz tabulate-xyz generate-xyz-includes $(AXY_LIB)

parse-xyz:
	@rm -rf $(AXY_TMP_DIR)
	@$(OC) -package str -linkpkg $(AXY_PARSE_DIR)/XYZParser.ml -o XYZParser
	@./XYZParser $(AXY_DATA_DIR)/*.xyz
	@rm -rf XYZParser
	@mkdir -p $(AXY_TMP_DIR)
	@mv xyz_*.f90 $(AXY_TMP_DIR)

# write one module filename per line so the main program knows what's available
tabulate-xyz:
	@for f in $(AXY_DATA_DIR)/*.xyz; do \
		echo "xyz_$$(basename "$$f" .xyz)_mod.mod"; \
	done > $(AXY_LST)

# produce mod_uses.inc and mod_switches.inc for compile-time molecule dispatch
generate-xyz-includes:
	@$(OC) $(AXY_PARSE_DIR)/ModParser.ml -o ModParser
	@./ModParser $(AXY_LST)
	@rm -rf ModParser
	@mv mod_uses.inc $(AXY_USE)
	@mv mod_switches.inc $(AXY_SWT)

$(AXY_ATM_OBJ): $(AXY_ATM_SRC)
	@$(FC) $(CFLAGS) -I$(MOD_DIR) -J$(MOD_DIR) -c $< -o $@

$(OBJ_DIR)/xyz_%.o: $(AXY_TMP_DIR)/xyz_%.f90
	@echo "compiling: $<"
	@$(FC) $(CFLAGS) -I$(MOD_DIR) -J$(MOD_DIR) -c $< -o $@

$(AXY_LIB): $(AXY_ATM_OBJ) $(AXY_XYZ_OBJ)
	@ar rcs $@ $^
	@rm -rf $(AXY_TMP_DIR)

# ============================================================================
# Freq LIBRARY BUILD
# ============================================================================
Freq: $(FREQ_LIB)

$(FREQ_OBJ): $(FREQ_SRC)
	@$(FC) $(CFLAGS) -I$(MOD_DIR) -J$(MOD_DIR) -c $< -o $@

$(FREQ_LIB): $(FREQ_OBJ)
	@ar rcs $@ $^

# ============================================================================
# ESTIMATE LIBRARY BUILD
# ============================================================================
Estimate: $(EST_LIB)

$(EST_OBJ): $(EST_SRC)
	@$(FC) $(CFLAGS) -I$(MOD_DIR) -J$(MOD_DIR) -c $< -o $@

$(EST_LIB): $(EST_OBJ)
	@ar rcs $@ $^

# ============================================================================
# CSV_INTERFACE LIBRARY BUILD
# Links against the OCaml runtime (asmrun_pic) so that CsvOut.ml can be
# called from Fortran through the C bridge.
# ============================================================================
CsvInterface: check-deps-csv $(CSV_LIB)

$(CSV_BRD_OBJ): $(CSV_BRD_SRC)
	@$(CC) -I$(shell ocamlc -where) -DCAML_NAME_SPACE -fPIC -c -o $@ $<

$(CSV_OUT_OBJ): $(CSV_OUT_SRC)
	@$(OC) -output-obj -package csv -linkpkg -o $@ $<

$(CSV_API_OBJ): $(CSV_API_SRC)
	@$(FC) $(CFLAGS) -I$(MOD_DIR) -J$(MOD_DIR) -c $< -o $@

$(CSV_LIB): $(CSV_BRD_OBJ) $(CSV_OUT_OBJ) $(CSV_API_OBJ)
	@ar rcs $@ $^

# ============================================================================
# MAIN EXECUTABLE BUILD
# Final link step: all static libraries + OCaml CSV objects + OCaml runtime.
# ============================================================================
main: $(MAIN_EXE)

$(MAIN_EXE): $(MAIN_SRC) $(wildcard $(LIB_DIR)/*.a)
	@$(FC) $(CFLAGS) -I$(INC_DIR) -I$(MOD_DIR) -J$(MOD_DIR) $(MAIN_SRC) \
		$(FF_LIB) $(AXY_LIB) $(FREQ_LIB) $(EST_LIB) \
		$(CSV_BRD_OBJ) $(CSV_OUT_OBJ) $(CSV_API_OBJ) \
		-L$(shell ocamlc -where) -lasmrun_pic -ldl -lm -lpthread \
		-o $(MAIN_EXE)
		
# ============================================================================
# OCAML DEPENDENCY CHECKING
# Verifies ocamlfind is available, then checks for required packages.
# Missing packages trigger an interactive install prompt via opam.
# ============================================================================
check-ocaml:
	@which $(OCAMLFIND) > /dev/null 2>&1 || \
		(echo "ERROR: ocamlfind not found. Please install OCaml and opam first." && \
		echo "Visit: https://ocaml.org/docs/install.html" && \
		exit 1)

check-deps-csv: check-ocaml
	$(call check_and_install,csv)

check-deps-yojson: check-ocaml
	$(call check_and_install,yojson str)

check-deps-str: check-ocaml
	$(call check_and_install,str)

define check_and_install
	@missing="" ; \
	for pkg in $(1); do \
		if ! $(OCAMLFIND) query $$pkg > /dev/null 2>&1; then \
			missing="$$missing $$pkg" ; \
		fi ; \
	done ; \
	if [ -n "$$missing" ]; then \
		echo "Missing OCaml packages:$$missing" ; \
		echo "" ; \
		echo "Would you like to install them now? [y/N]" ; \
		read -r response ; \
		if [ "$$response" = "y" ] || [ "$$response" = "Y" ]; then \
			echo "Installing OCaml packages:$$missing" ; \
			$(OPAM) install -y $$missing ; \
		else \
			echo "Please install manually with: opam install$$missing" ; \
			exit 1 ; \
		fi ; \
	fi
endef

# ============================================================================
# PDB TO XYZ FILE CONVERTER
# Optional utility; only built when PDB_TARGET is set by the caller.
# ============================================================================
compile-pdb-2-xyz: $(PDB_EXE)

$(PDB_OBJ): $(PDB_SRC)
	@$(FC) $(CFLAGS) -J$(MOD_DIR) -c $< -o $@

$(PDB_EXE): $(PDB_OBJ)
	@$(FC) $(PDB_OBJ) -o $(PDB_EXE)

# interactive helper: prompts for a PDB file, converts it, and moves the
# resulting .xyz into the AtomXYZ data directory for the next build
pdb-2-xyz:
	@read -p "Enter xyz filename: " file; \
	./$(PDB_EXE) $$file; \
	mv *.xyz $(AXY_DATA_DIR)


# ============================================================================
# POSTAMBLE
# ============================================================================
postamble:
	@echo "=================================="
	@echo "Compilation complete ($(BUILD_TYPE))"
	@echo "Compiled xyz molecules: $(AXY_LST)"
	@echo "Executable: $(MAIN_EXE)"
	@echo "=================================="

# ============================================================================
# CLEAN TARGETS
# Delegated to BuildClean.mk; the target name is passed through as-is.
# ============================================================================
clean clean-objects clean-build clean-formfacts clean-all:
	@$(MAKE) -f BuildClean.mk $@